#!/bin/bash
exec scala "$0" "$@"
!#

import java.awt.Color
import java.util.GregorianCalendar
import java.util.Calendar
import java.io.File

import scala.collection.mutable.HashMap
import scala.collection.JavaConversions._
import scala.util.Random

import org.goobs.internet._
import org.goobs.graphics.Drawing

//------------------------------------------------------------------------------
// PARAMETERS
//------------------------------------------------------------------------------
// -- Drawing Params --
val borderWidth = 4
val gridWidth = 2

val drawMonth = true
val drawDates = false

val sleepEnd = 6
val sleepStart = 22

// -- Web Params --
val imagePath = "img"
val monthSize = 500
val daySize = 500

// -- Static --
val MOY = Array[String](
	"JAN",
	"FEB",
	"MAR",
	"APR",
	"MAY",
	"JUN",
	"JUL",
	"AUG",
	"SEP",
	"OCT",
	"NOV",
	"DEC"
)

// -- State --
object State {
	val sessionID = Random.nextInt
	var nextID:Int = 0
}

def isNight(hr:Int) = {
	hr < sleepEnd || hr >= sleepStart
}

//------------------------------------------------------------------------------
// CALENDARS
//------------------------------------------------------------------------------
class Freedom(val year:Int,val mon:Int,freedom:Array[Boolean]) {
	def export:Drawing = {
		val cal:Calendar = new GregorianCalendar
		if(cal.get(Calendar.YEAR) == year && cal.get(Calendar.MONTH)+1 == mon){
			export(cal.get(Calendar.DAY_OF_MONTH))
		} else {
			export(-1)
		}
	}
	def export(today:Int):Drawing = {
		//--Variables
		//(create calendar)
		val cal:Calendar = Freedom.calendar
		cal.set(year,mon-1,1)
		//(get statistics)
		val numDays = cal.getActualMaximum(Calendar.DAY_OF_MONTH)
		//(create frame)
		val frame:Drawing = new Drawing()
		//--Block Days
		//(function)
		def mark(frame:Drawing,x:Double,y:Double,hr:Int):Drawing = {
			val hour = hr.asInstanceOf[Double] / 24.0
			val x0 = x
			val x1 = 1.0+x
			val y0 = y-hour
			val y1 = y-hour-(1.0/24.0)
			if(isNight(hr)){
				frame.fillRect(x0,y0,x1,y1,new Color(0xEAEAEA))
			} else {
				frame.fillRect(x0,y0,x1,y1,new Color(0x9FC6E7))
			}
		}
		//(mark)
		val freed:Drawing = freedom.zipWithIndex.foldLeft(frame){ 
				case (frame:Drawing,(free:Boolean,hr:Int)) =>
			//(get date)
			val day:Int = hr / 24
			cal.set(year,mon-1,day)
			val dow:Int = cal.get(Calendar.DAY_OF_WEEK)-1
			val week:Int = cal.get(Calendar.WEEK_OF_MONTH)
			//(mark date)
			if(free){
				frame
			} else {
				mark(frame,dow,6-week,(hr % 24))
			}
		}
		//--Finish Calendar
		Freedom.flourish(Freedom.frame(freed,year,mon),year,mon,today)
	}
	def day(day:Int):Drawing = {
		//--Variables
		//(create calendar)
		val cal:Calendar = Freedom.calendar
		cal.set(year,mon-1,day)
		//(get freedom)
		val freeDay:Array[Boolean] = freedom.slice((day-1)*24,(day-1+1)*24)
		//(create frame)
		val frame:Drawing = new Drawing()
		//--Block Hours
		val blocked:Drawing = freeDay.zipWithIndex.foldLeft(frame){ 
				case (frame:Drawing,(free:Boolean,hour:Int)) =>
			if(free){
				frame
			} else if(isNight(hour)){
				frame.fillRect(3,24-hour-1,14,24-hour, new Color(0xEAEAEA))
			} else {
				frame.fillRect(3,24-hour-1,14,24-hour, new Color(0x9FC6E7))
			}
		}
		//--Finish Calendar
		Freedom.day(blocked,year,mon,day)
	}
	override def toString:String = freedom.mkString(",")
}

object Freedom {
	def apply(year:Int,month:Int):Freedom = apply(year,month,Random.nextInt)
	def apply(year:Int,month:Int,seed:Int):Freedom = {
		//--Variables
		//(create calendar)
		val cal = new GregorianCalendar
		cal.setFirstDayOfWeek(Calendar.SUNDAY)
		cal.set(year,month-1,1)
		//(get numbers)
		val numDays = cal.getActualMaximum(Calendar.DAY_OF_MONTH)
		val numHours = numDays * 24
		//--Run Chain
		val chain = (0 until numHours).foldLeft((List[Boolean](),true)){ 
				case ((free:List[Boolean],freeAllDay:Boolean),hr:Int) =>
			//(variables)
			val hod:Int = hr % 24
			//(transition probs)
			val isFree = if(isNight(hod)){
				false
			} else if(hod == sleepEnd) {
				Random.nextBoolean
			} else {
				val lastFree = if(free.isEmpty){ true } else { free.head }
				if(freeAllDay){
					Random.nextDouble < 0.95
				} else if(lastFree){
					Random.nextDouble < 0.5
				} else {
					Random.nextDouble < 0.3
				}
			}
			//(return)
			(isFree :: free, hod == sleepEnd-1 || (freeAllDay && isFree))
		}._1.reverse.toArray
		//--Return
		new Freedom(year,month,chain)
	}
	def calendar:GregorianCalendar = {
		val cal = new GregorianCalendar
		cal.setFirstDayOfWeek(Calendar.SUNDAY)
		cal
	}
	def frame(canvas:Drawing,year:Int,month:Int):Drawing = {
		//--Functions
		def invalid(frame:Drawing,row:Int,col:Int) = {
			frame.fillRect(col,5-row,col+1,6-row, Color.BLACK)
		}
		val cal:Calendar = calendar
		//--Make Frame
		val emptyCal:Drawing = canvas
			//(boundary)
			.rect(0,0,7,6,Color.BLACK,borderWidth)
			//(grid)
			.line(1,0,1,5,Color.BLACK,gridWidth)
			.line(2,0,2,5,Color.BLACK,gridWidth)
			.line(3,0,3,5,Color.BLACK,gridWidth)
			.line(4,0,4,5,Color.BLACK,gridWidth)
			.line(5,0,5,5,Color.BLACK,gridWidth)
			.line(6,0,6,5,Color.BLACK,gridWidth)
			.line(0,1,7,1,Color.BLACK,gridWidth)
			.line(0,2,7,2,Color.BLACK,gridWidth)
			.line(0,3,7,3,Color.BLACK,gridWidth)
			.line(0,4,7,4,Color.BLACK,gridWidth)
			.line(0,5,7,5,Color.BLACK,gridWidth)
			//(title)
			.text(1.6,5.125,
				{if(drawMonth){ MOY(month-1)+" "+year } else { "" }},
				Color.BLUE,0.75)
		//--Bound Calendar
		//(bound first)
		cal.set(year,month-1,1)
		val firstDow:Int = cal.get(Calendar.DAY_OF_WEEK)-1
		val firstWeek:Int = cal.get(Calendar.WEEK_OF_MONTH)
		val boundedCalLeft:Drawing = (0 until firstDow)
				.foldLeft(emptyCal){ case (frame:Drawing,day:Int) =>
			invalid(frame,firstWeek,day)
		}
		//(bound last)
		cal.set(year,month-1,cal.getActualMaximum(Calendar.DAY_OF_MONTH))
		val lastDow:Int = cal.get(Calendar.DAY_OF_WEEK)-1
		val lastWeek:Int = cal.get(Calendar.WEEK_OF_MONTH)
		(lastDow+1 until 7)
				.foldLeft(boundedCalLeft){ case (frame:Drawing,day:Int) =>
			invalid(frame,lastWeek,day)
		}
	}

	def flourish(frame:Drawing,year:Int,month:Int,today:Int):Drawing = {
		//--Functions
		def number(frame:Drawing,x:Double,y:Double,num:Int):Drawing = {
			frame.text({if(num > 9) 0.6 else 0.8}+x, 
				0.75+y, 
				""+num, 
				new Color(0x2E3542),
				0.25)
		}
		def mark(frame:Drawing,x:Double,y:Double):Drawing = {
			frame.fillCircle(0.5+x, 0.4+y, 0.25, new Color(0xFF7F6E))
		}
		//--Draw Calendar
		val cal:Calendar = calendar
		cal.set(year,month-1,1)
		val markedCal:Drawing = (1 to cal.getActualMaximum(Calendar.DAY_OF_MONTH))
				.foldLeft(frame){ case (frame:Drawing,day:Int) =>
			if(drawDates || day == today || (today < 0 && day == 1)){
				//(get date)
				cal.set(year,month-1,day)
				val dow:Int = cal.get(Calendar.DAY_OF_WEEK)-1
				val week:Int = cal.get(Calendar.WEEK_OF_MONTH)
				//(label date)
				number(frame,dow,5-week,day)
			} else {
				frame
			}
		}
		//--Set Today
		if(today > 0){
			//(get date)
			cal.set(year,month-1,today)
			val dow:Int = cal.get(Calendar.DAY_OF_WEEK)-1
			val week:Int = cal.get(Calendar.WEEK_OF_MONTH)
			//(mark date)
			mark(markedCal,dow,5-week)
		} else {
			markedCal
		}
	}
	
	def day(canvas:Drawing,year:Int,month:Int,day:Int):Drawing = {
		val boundary:Drawing = canvas
			.rect(0,0,14,24,Color.BLACK,borderWidth)
			.line(3,0,3,24,Color.BLACK,2)
		val emptyDay:Drawing = (0 until 24).foldLeft(boundary){
				case (frame:Drawing, hour:Int) =>
			val tMod12:Int = 
				if(hour == 0 || hour == 12) 12
				else if(hour < 12) hour
				else hour-12
			val time:String = ""+tMod12 +
				{if(tMod12 < 10) "  " else " "} +
				{if(hour >= 12) "pm" else "am"}
			frame
				.line(0,24-hour-1,14,24-hour-1)
				.text(0.1, 24-hour-1+0.1, time, new Color(0x2E3542), 0.8)
		}
		emptyDay
	}
}


//Freedom(2011,12).export(4).preview(500)
//Freedom(2011,12).export.preview(500)
//Freedom.day(new Drawing(),2011,11,27).preview(500)
//Freedom(2011,11).day(27).preview(500)


//------------------------------------------------------------------------------
// WEB SERVER
//------------------------------------------------------------------------------

//--New Session
def getID(values:HashMap[String,String],info:WebServer.HttpInfo):String = {
	State.nextID = State.nextID + 1
	println("[" + State.nextID + "] connect")
	State.nextID.toString
}
//--Get Month
def getMonth(id:Int,year:Int,month:Int):String = {
	if(id < 0 || id > State.nextID){ 
		throw new IllegalArgumentException("Bad ID: " + id) 
	}
	val filepath = imagePath+"/"+State.sessionID+"_"+id+"_"+year+"-"+month+".png"
	if(!(new File(filepath).exists)){
		Freedom(year,month).export.save(filepath,monthSize)
	}
	println("[" + id + "] month view " + year + "-"+month)
	filepath
}
def getMonth(values:HashMap[String,String],info:WebServer.HttpInfo):String = {
	getMonth(values("id").toInt,values("year").toInt,values("month").toInt)
}
//--Get Day
def getDay(id:Int,year:Int,month:Int,day:Int):String = {
	if(id < 0 || id > State.nextID){ 
		throw new IllegalArgumentException("Bad ID: " + id) 
	}
	val filepath 
		= imagePath+"/"+State.sessionID+"_"+id+"_"+year+"-"+month+"-"+day+".png"
	if(!(new File(filepath).exists)){
		Freedom(year,month).day(day).save(filepath,daySize)
	}
	println("[" + id + "] day view " + year + "-"+month + "-" + day)
	filepath
}
def getDay(values:HashMap[String,String],info:WebServer.HttpInfo):String = {
	getDay(
		values("id").toInt,
		values("year").toInt,
		values("month").toInt,
		values("day").toInt)
}

//--Add Listeners
//(implicit conversion)
implicit def fn2handler(
		fn:(HashMap[String,String],WebServer.HttpInfo)=>String):WebServerHandler = {
	new JsonHandler(){
		override def handleJSON(values:java.util.HashMap[String,String],
				info:WebServer.HttpInfo):String = {
			//(convert hashmap)
			val scalaMap:HashMap[String,String] = new HashMap[String,String]
			val iter = values.keySet.iterator
			while(iter.hasNext){
				val key = iter.next
				scalaMap(key) = values.get(key)
			}
			//(handle)
			try{
				"{\n  \"value\":\"" + fn(scalaMap,info) +"\"\n}"
			} catch {
				case (r:RuntimeException) => 
					r.printStackTrace
					"ERROR: " + r.getMessage
			}
		}
	}
}
//(add handlers)
new WebServer(3000).start
	.register("/init",getID(_:HashMap[String,String],_:WebServer.HttpInfo))
	.register("/month",getMonth(_:HashMap[String,String],_:WebServer.HttpInfo))
	.register("/day",getDay(_:HashMap[String,String],_:WebServer.HttpInfo))

println("Running...")
