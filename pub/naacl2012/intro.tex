
\Section{intro}{Introduction}
% -- Intro
Temporal resolution is the task of mapping from a textual phrase describing
	a potentially complex time, date or duration expression, to a normalized 
	temporal representation.

% -- Temporal Comparison
%(intro to systems)
The dominant approach to this problem in previous work has been to use
	rule-based methods, generally a combination of regular-expression matching
	followed by hand-written interpretation functions
	% Edinburgh, TRIPS/TRIOS, TERSEO, KUL, Marta's Friend, random,
	\cite{key:2000mani-temporal,key:2003saquete-temporal,key:2004puscasu-temporal,key:2010grover-temporal,key:2010uzzaman-temporal,key:2010kolomiyets-temporal,key:2010strotgen-temporal}.
%We in particular compare against \sys{HeidelTime} 
%	\cite{key:2010strotgen-temporal}, which won the \tempeval\ 
%	task at SemEval 2010.

% -- Motivation
%(motivation)
In general, it is appealing to learn the interpretation of temporal expressions,
	rather than hand-building systems, but beyond this general motivation,
	we note that complex temporal expressions such as \tp{the Tuesday before last}
	or \tp{the third Wednesday of each month} are poorly handled by current
	systems and suggest the need for recursive phrase structure representations.
%(approach)
Therefore, in contrast to previous rule-based approaches, we attempt to learn
	a temporal interpretation system where temporal phrases are parsed by
	a grammar, but this grammar and its semantic interpretation rules are
	latent, with only the input phrase and its grounded interpretation given
	to the learning system.

% -- Approach
%(ambiguity)
Employing probabilistic techniques allows us to capture ambiguity in temporal 
	phrases in two important respects.
In part, it captures syntactic ambiguity -- as in \tp{last Friday
	the \th{13}} referring may bracket as \tp{[last Friday] [the \th{13}]}, or
	\tp{last [Friday the \th{13}]}.
In addition, temporal expressions often carry a pragmatic ambiguity.
For instance, a speaker may refer to either the next or previous Friday
	when he utters \tp{Friday} on a Sunday.
Furthermore, probabilistic systems in general allow propagation of uncertainty
	to higher-level components -- for example recognizing that \tp{May} could
	hav a number of non-temporal meanings and allowing a system with a broader
	contextual scope to make the final judgment.

%(table of contents)
We describe our temporal representation
	(\refsec{repr}), followed by the learning algorithm
	(\refsec{learn}); we conclude with experimental results 
	(\refsec{result}) showing our
	approach to be competitive with state of the art systems.


\Section{related}{Related Work}
% -- Semantic Parsing Comparison
Our approach draws inspiration from a large body of work
	on parsing expressions into a logical form.
The latent parse parallels the formal semantics of previous work,
	e.g., Montague Semantics.
Like these representations, a parse -- in conjunction with
	the reference time -- completely defines a set of
	matching entities, in this case the single grounded time.

%(supervised)
Supervised approaches to the task prominently include
	\newcite{key:1996zelle-semantics},
	\newcite{key:2005zettlemoyer-semantics},
	\newcite{key:2005kate-semantics}, 
	\newcite{key:2007zettlemoyer-semantics}, 
	\textit{inter alia}.
We loosen the supervision required in these systems by allowing the parse to
	be latent;
	the annotation of the grounded time neither defines, nor gives any
	direct cues about the elements of the latent parse, since many parses evaluate
	to the same grounding.
To demonstrate, the date corresponding to \te{a week ago today} could be
	specified as a month and day, or as a \tp{week ago}, or as \tp{last
	Friday} -- substituting today's day of the week for \tp{Friday}.
Each of these correspond to a completely different parse.

%(distantly supervised)
Recent work by \newcite{key:2010clarke-semantics} and 
	\newcite{key:2011liang-semantics} similarly relax supervision 
	to require only annotated answers rather than full logical forms.
For example, \newcite{key:2011liang-semantics} constructs a latent parse
	similar in structure to a dependency grammar, but representing a logical
	form.
Our proposed lexical entries and combination rules can be though of as
	paralleling the lexical entries and predicates, and the implicit combination 
	rules respectively in this framework.
Rather than querying from a finite database, however, our system must compare
	temporal expression within an infinite timeline.
Furthermore, our system is run using neither lexical cues nor intelligent
	initialization.

